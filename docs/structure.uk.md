# Структура Проєкту

FinMan — це складний застосунок, що використовує **Гібридну Архітектуру** для забезпечення масштабованості, підтримки та чіткого розділення відповідальності.
Проєкт структурований так, щоб суворо відокремити **Клієнтську логіку** (Браузер, IndexedDB, React) від **Серверної логіки** (Node.js, PostgreSQL, API), забезпечуючи при цьому спільний простір для контрактів даних.

## Загальний огляд

Весь вихідний код знаходиться в папці `src`, щоб відокремити його від конфігураційних файлів.
Папка `src` поділена на чотири основні шари:

* **`app/`**: **Шар Маршрутизації (Routing)**. Містить лише файли маршрутизації Next.js.
  Виступає як "Тонкий шар", що з'єднує користувача/запит з логікою.
* **`client/`**: **Фронтенд Шар**.
  Містить весь код, що виконується в браузері. Дотримується принципів **Feature-Sliced Design (FSD)**.
* **`server/`**: **Бекенд Шар**.
  Містить бізнес-логіку, взаємодію з базою даних та use cases. Дотримується принципів **Domain-Driven Design (DDD)**.
* **`common/`**: **Шар Спільних Контрактів**. Містить код, спільний для Клієнта та Сервера (Типи, Інтерфейси, Константи, Рекорди).
  **ТУТ ЗАБОРОНЕНО:** бізнес-логіку, бібліотеки виконання (як Zod) або прямий доступ до БД.

---

## 1. Термінологія та Моделі Даних (Важливо)

Щоб уникнути плутанини між шарами Фронтенду, Бекенду та Бази Даних, ми використовуємо специфічні суфікси:

| Термін | Розташування | Відповідальність | Приклад |
| :--- | :--- | :--- | :--- |
| **Record (Запис)** | `common/records/` | **Форма БД**. Чисті інтерфейси, що відображають структуру таблиці 1-в-1. Спільні для FE та BE. | `UserRecord`, `BudgetPlanRecord` |
| **Entity (FE)** | `client/entities/` | **FSD Слайс**. Папка, що містить UI, Store та клієнтську логіку для бізнес-юніту. | `client/entities/user-profile/` |
| **Entity (BE)** | `server/entities/` | **DDD Клас**. Клас із методами та поведінкою, що інкапсулює бізнес-правила на сервері. | Клас `UserOrm` |
| **DTO** | `common/models/` | **Data Transfer Object**. Контракти для запитів/відповідей API (якщо відрізняються від Record). | `CreateUserDto` |

---

## 2. Директорія App (`src/app`)
**Призначення:** Тільки маршрутизація та точки входу.
Ця папка не повинна містити складної бізнес-логіки або UI компонентів.

* **Pages & Layouts**: Точки композиції (зборки) сторінок.
* **API Routes**: Повинні лише парсити запит і викликати **Services/UseCases** з папки `server/features`.

---

## 3. Директорія Client (`src/client`)
**Архітектура:** Feature-Sliced Design (FSD).
**Відповідальність:** Логіка браузера, UI, взаємодія з IndexedDB.

### Структура
* **`widgets/`**: Незалежні, самодостатні UI блоки.
* **`features/`**: Сценарії користувача (наприклад, `RegistrationPage`).
* **`entities/`**: Бізнес-сутності (FSD Слайси).
    * Містить `services/`, `models/`, та Zustand стори.
    * *Примітка:* Використовує `Records` для типізації "сирих" даних з API/БД.
* **`repositories/`**: Шар абстракції доступу до даних (перемикання між API та LocalDB).
* **`database/`**: **Клієнтська База Даних** (обгортка над IndexedDB).
* **`shared/`**: Перевикористовуваний інфраструктурний код (компоненти, хуки, утиліти).

---

## 4. Директорія Server (`src/server`)
**Архітектура:** Domain-Driven Design (DDD).
**Відповідальність:** Бізнес-логіка, PostgreSQL/ORM, обробка API.

### Структура
* **`entities/`**: **Core Domain Objects (Shared Kernel)**.
    * Спільні бізнес-класи, які використовуються в декількох фічах (наприклад, `UserOrm`).
    * Містять чисту бізнес-логіку.
    * Використовують `Records` з `common/` як структуру даних.
* **`features/`**: Ізольовані бізнес-модулі (наприклад, `budget`, `auth`).
  Кожна папка фічі поділена на шари:
    * **`domain/`**: Локальні бізнес-правила та сутності, специфічні *тільки* для цієї фічі.
    * **`application/`**: Use Cases, Сервіси та Валідація. Координує потік даних.
    * **`infrastructure/`**: Пряма взаємодія з базою даних або зовнішніми API.
* **`shared/`**: Серверні утиліти.

---

## 5. Директорія Common (`src/common`)
**Призначення:** Чиста типізація та спільні контракти.

**Вміст:**
* **`records/`**: Визначення таблиць бази даних (наприклад, `BudgetPlanRecord`). **Головне джерело правди про форму даних.**
* **`models/`**: Спільні DTO та Типи.
* **`constants/`**: Спільні константи.
* **`utils/`**: Спільні утиліти (тільки чистий JS/TS).

---

## Правила Залежностей (Суворі)

Щоб зберегти модульність і запобігти циклічним залежностям, необхідно дотримуватися наступних правил імпорту:

1.  **Клієнт проти Сервера (Абсолютний бар'єр):**
    * `client/` **ЗАБОРОНЕНО** імпортувати з `server/`.
    * `server/` **ЗАБОРОНЕНО** імпортувати з `client/`.
    * **Виняток:** Обидва шари взаємодіють тільки через API (HTTP) і використовують спільні контракти з `common/`.

2.  **Шар Common (Фундамент):**
    * `common/` **ЗАБОРОНЕНО** імпортувати будь-що з `client/` або `server/`.
    * Він повинен залишатися чистим (Типи, Рекорди, Константи, Утиліти).

3.  **Records проти Entities (Дані проти Поведінки):**
    * `server/entities` (DDD Класи) залежать від `common/records` (Форма даних).
    * `client/entities` (FSD Слайси) залежать від `common/records` (Форма даних).

4.  **Клієнтська частина (Ієрархія FSD):**
    * Правило: **"Можна імпортувати тільки знизу"**.
    * `app` -> імпортує `widgets`, `features`, `entities`, `shared`.
    * `widgets` -> імпортують `features`, `entities`, `shared`.
    * `features` -> імпортують `entities`, `shared`. (**Не можуть** імпортувати інші фічі).
    * `entities` -> імпортують `shared`, `repositories`, `database`. (**Не можуть** імпортувати інші сутності).
    * `shared` -> нічого не імпортує з верхніх шарів.

5.  **Серверна частина (DDD та Модульність):**
    * **Shared Kernel:** Фічі (`server/features/*`) **МОЖУТЬ** імпортувати з `server/entities` (Спільні сутності) та `server/shared`.
    * **Ізоляція Фіч:** Одна фіча (наприклад, `budget`) **НЕ ПОВИННА** напряму імпортувати код з іншої фічі (наприклад, `auth`).
    * **Шари DDD:**
        * `infrastructure` залежить від `domain` та `application`.
        * `application` залежить від `domain`.
        * `domain` є **незалежним** (залежить тільки від `common/` та `server/entities`).